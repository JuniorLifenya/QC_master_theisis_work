import numpy as np
import qutip as qt
import matplotlib.pyplot as plt
from qutip import (Qobj, about, basis, coherent, coherent_dm, create, destroy,
                   expect, fock, fock_dm, mesolve, qeye, sigmax, sigmay,
                   sigmaz, tensor, thermal_dm, anim_matrix_histogram,
                   anim_fock_distribution, Bloch, fidelity, concurrence,sigmam)

# We set a parameter to see animations in line 
from matplotlib import rc
rc('animation', html='jshtml')

#----------- Introduction ---------------------------------------------------#

q1 = Qobj([[1, 0], [0, 0]])  # |0><0| Well this one is apparently an operator
q2 = Qobj([[1], [0]])  # |0> This is just a state vector with one column
#print(q1)
#print(q2)

# Useful properties of Qobj 
# print(f"Shape of q1 is: {q1.shape}")
# print(f"Type of q1 is: {q1.type}")
# print(f"Dimension of q1 is: {q1.dims}")
# print(f"Is q1 Hermitian? {q1.isherm}")
# print(f"Is q1 unitary? {q1.isunitary}")
# print(f"Dense matrix representation of q1:\n{q1.full()}")
# print(f"Conjugate transpose of q1:\n{q1.dag()}")
# print(f"Eigenvalues of q1: {q1.eigenenergies()}")

# Now faster with fundamental basis states (Fock states of oscillatior modes)

basis(2, 0)  # |0> same as fock(2,0)
basis(2, 1)  # |1> same as fock(2,1)
basis(2, 0).dag()  # <0| same as fock(2,0).dag()
basis(2, 1).dag()  # <1| same as fock(2,1).dag()

print(f" |0><0| : {(basis(2, 0) * basis(2, 0).dag())}")   # |0><0| same as fock_dm(2,0)



#----------- Introduction ---------------------------------------------------#

#----------- Simple setup ---------------------------------------------------#

# We will start with a simple model of an NV-center as a spin-1 system.
# In doing so we define H = [delta/2]sigmax 
# We define an additional collaps operator , describing the dissipation
# Of energy from the qubit to an external environment. C = [sqrt(g)]sigmaz

delta = 2* np.pi 

g = 0.25 

# Hamiltonian 
H = (delta/2) * sigmax()

# Collapse operators
c_ops = [np.sqrt(g) * sigmaz()]

# Initial state
psi0 = basis(2,0)  # Ground state

# Time vector
tlist = np.linspace(0, 5, 100)

#----------- Simple setup ---------------------------------------------------#



#----------- Passing values -------------------------------------------------#

res = mesolve(H,psi0,tlist,c_ops,[sigmaz()])

# For this perticular Hamiltonian and dissipation process , we can derive 
# The analytical solution for the expectation value of sigmaz

sz_analytical = np.cos(2*np.pi*tlist) * np.exp(-g*tlist)

#We can acces the expectation value generated by the mesolve by accesing res.expect[0]

#----------- Passing values -------------------------------------------------#


#----------- Plotting values ------------------------------------------------#

plt.scatter(tlist,res.expect[0],label='Numerical ')
plt.scatter(tlist, res.expect[0], c = "r", marker = "x", label = "mesolve")
plt.plot(tlist,sz_analytical, label = "Analytical", c = "k")
plt.xlabel('Time'), plt.ylabel('<sigmaz>')
plt.legend()
plt.grid()
plt.title("Qubit dynamics with dissipation")
plt.show()

#----------- Plotting values -----------------------------------------------#

#----------- Bloch sphere ---------------------------------------------------#

# First consider the following hamiltonian H = delta(costsigmaz + sintsigmax)
# t defines the angle of the qubit state between the z-axis towards the x-axis 
# We can again use mesolve to obtain the dynamics of the system.
# Here we pass an ampty list of collapse operators to indicate that we do not
# Want to include any dissipation in the system

t = 0.2*np.pi

H = delta *(np.cos(t) * sigmaz() + np.sin(t) * sigmax())

# Obtain Time Evolution 
tlist = np.linspace(0,5,200) # Change for better resolution, sircle-radius and smoothness
result = mesolve(H, psi0, tlist, [], [sigmax(), sigmay(), sigmaz()])

#----------- Bloch sphere ---------------------------------------------------#

#----------- Plotting Bloch sphere ------------------------------------------#
# We can visulaize the state on the Bloch sphere using qutip.Bloch class. 
# We can add points to the Block sphere and also vectors representing states. 

exp_sx_circ, exp_sy_circ, exp_sz_circ = result.expect 
exp_sx_circ, ex_sy_circ,  exp_sz_circ = (
    np.array(exp_sx_circ),
    np.array(exp_sy_circ),
    np.array(exp_sz_circ),
)

b = Bloch()
b.add_points([exp_sx_circ, exp_sy_circ, exp_sz_circ], 'm') # 's' for sphere and 'l' for line, you can also mix them 
b.add_states(psi0)

# Create a larger figure so the title has room (optional)
b.fig = plt.figure(figsize=(9, 9))
# Put suptitle on the figure before drawing
b.fig.suptitle("Coherent evolution", fontsize=40, y=0)

# Make room at the top so the title isn't clipped
b.fig.subplots_adjust(top=0.98)
b.show()
#plt.show()

#----------- Plotting Bloch sphere ------------------------------------------#

#----------- Changing phase -------------------------------------------------#

#To change the phase we introduce the following collapse operator:
# C = [sqrt(g) * sigmay] 
g_phase = 0.5 # Change and observe later what happens(more sircle rounds)
c_ops2 = [np.sqrt(g_phase) * sigmaz()]

# Solve the dynamics
result_phase = mesolve(H,psi0,tlist,c_ops2, [sigmax(), sigmay(), sigmaz()])
exp_sx_dephase , exp_sy_dephase, exp_sz_dephase = result_phase.expect# type: ignore
exp_sx_dephase , exp_sy_dephase, exp_sz_dephase= (
    np.array(exp_sx_dephase),
    np.array(exp_sy_dephase),
    np.array(exp_sz_dephase),
)

b_phase = Bloch()
b_phase.add_points([exp_sx_dephase , exp_sy_dephase, exp_sz_dephase], meth='l')
b_phase.add_states(psi0)

# Create a larger figure so the title has room (optional)
b_phase.fig = plt.figure(figsize=(9, 9))  
# Put suptitle on the figure before drawing
b_phase.fig.suptitle("Dephasing with rate g = 0.5", fontsize=40, y=0)

# Make room at the top so the title isn't clipped
b_phase.fig.subplots_adjust(top=0.98)
b_phase.show()
#plt.show()

#----------- Changing phase -------------------------------------------------#

#----------- Qubit relaxation -------------------------------------------------#

#Another type of dissipation is the relaxation of the qubit 
# Originating form the following collapse operator:
# C = [sqrt(gr) * sigma_] 
# This induces spontaneous flips of the qubit from the excited state to the ground state.
# With a rate gr. We can observe the qubit dynamics on the Bloch sphere by defining:
g_relax = 0.5 # Change and observe later what happens
c_ops3 = [np.sqrt(g_relax) * sigmam()]

# Solve the dynamics
result_relax = mesolve(H,psi0,tlist,c_ops3, [sigmax(), sigmay(), sigmaz()])
exp_sx_relax , exp_sy_relax, exp_sz_relax = result_relax.expect# type: ignore

b_relax = Bloch()
b_relax.add_points([exp_sx_relax , exp_sy_relax, exp_sz_relax], meth='l')
b_relax.add_states(psi0)

# Create a larger figure so the title has room 
b_relax.fig = plt.figure(figsize=(9, 9))
# Put subtitle on the figure before drawing
b_relax.fig.suptitle("Relaxation with rate gr = 0.5", fontsize=40, y=0)

# Make room at the bottom so the title isn't clipped
b_relax.fig.subplots_adjust(top=0.98)
b_relax.show()
#plt.show()

#----------- Qubit relaxation -------------------------------------------------#


#NB!With these methods you can explore different hamiltonians and dissipation processes
# Also simulate any dissipative quantum system , whose dynamics are described by the master eq. 
# See the qutip documentation for more details : http://qutip.org/docs/latest/guide/dynamics/dynamics-master.html



#///////////////////////////Now we level up the game////////////////////////////

#----------More advanced definitions---------------------------------------#
# Define NV-center spin-1 operators
Sx = qt.jmat(1, 'x')
Sy = qt.jmat(1, 'y')
Sz = qt.jmat(1, 'z')

Sx2 = Sx * Sx
Sy2 = Sy * Sy
Sz2 = Sz * Sz
#-------- We check their properties-------------------#
print(f"Shape of S_x is: {Sx.shape}")
#-------- We check their properties-------------------#
#----------More advanced definitions---------------------------------------#