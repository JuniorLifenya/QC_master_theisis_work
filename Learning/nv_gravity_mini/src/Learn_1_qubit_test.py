import numpy as np
import qutip as qt
from qutip import Bloch, about, basis, sigmam,sigmax, sigmay, sigmaz, mesolve
import matplotlib.pyplot as plt

#----------- Simple setup ---------------------------------------------------#

# We will start with a simple model of an NV-center as a spin-1 system.
# In doing so we define H = [delta/2]sigmax 
# We define an additional collaps operator , describing the dissipation
# Of energy from the qubit to an external environment. C = [sqrt(g)]sigmaz

delta = 2* np.pi 

g = 0.25 

# Hamiltonian 
H = (delta/2) * sigmax()

# Collapse operators
c_ops = [np.sqrt(g) * sigmaz()]

# Initial state
psi0 = basis(2,0)  # Ground state

# Time vector
tlist = np.linspace(0, 5, 100)

#----------- Simple setup ---------------------------------------------------#



#----------- Passing values -------------------------------------------------#
res = mesolve(H,psi0,tlist,c_ops,[sigmaz()])

# For this perticular Hamiltonian and dissipation process , we can derive 
# The analytical solution for the expectation value of sigmaz

sz_analytical = np.cos(2*np.pi*tlist) * np.exp(-g*tlist)

#We can acces the expectation value generated by the mesolve by accesing res.expect[0]

#----------- Passing values -------------------------------------------------#


#----------- Plotting values ------------------------------------------------#

plt.scatter(tlist,res.expect[0],label='Numerical ')
plt.scatter(tlist, res.expect[0], c = "r", marker = "x", label = "mesolve")

plt.plot(tlist,sz_analytical, label = "Analytical", c = "k")
plt.xlabel('Time'), plt.ylabel('<sigmaz>')
plt.legend()
plt.grid()
plt.show()

#----------- Plotting values -----------------------------------------------#

#----------- Bloch sphere ---------------------------------------------------#
# First consider the following hamiltonian H = delta(costsigmaz + sintsigmax)
# t defines the angle of the qubit state between the z-axis towards the x-axis 
# We can again use mesolve to obtain the dynamics of the system.
# Here we pass an ampty list of collapse operators to indicate that we do not
# Want to include any dissipation in the system

t = 0.2*np.pi

H = delta *(np.cos(t) * sigmaz() + np.sin(t) * sigmax())

# Obtain Time Evolution 
tlist = np.linspace(0,5,200) # Change for better resolution, sircle-radius and smoothness
result = mesolve(H, psi0, tlist, [], [sigmax(), sigmay(), sigmaz()])

#----------- Bloch sphere ---------------------------------------------------#

#----------- Plotting Bloch sphere ------------------------------------------#
# We can visulaize the state on the Bloch sphere using qutip.Bloch class. 
# We can add points to the Block sphere and also vectors representing states. 

exp_sx_circ, exp_sy_circ, exp_sz_circ = result.expect 
exp_sx_circ, ex_sy_circ,  exp_sz_circ = (
    np.array(exp_sx_circ),
    np.array(exp_sy_circ),
    np.array(exp_sz_circ),
)

b = Bloch()
b.add_points([exp_sx_circ, exp_sy_circ, exp_sz_circ], 'm')
b.add_states(psi0)
b.show()
plt.show()

#----------- Plotting Bloch sphere ------------------------------------------#

#----------- Changing phase -------------------------------------------------#

#To change the phase we introduce the following collapse operator:
# C = [sqrt(g) * sigmay] 
g_phase = 0.5 # Change and observe later what happens
c_ops2 = [np.sqrt(g_phase) * sigmaz()]

# Solve the dynamics
result_phase = mesolve(H,psi0,tlist,c_ops2, [sigmax(), sigmay(), sigmaz()])
exp_sx_dephase , exp_sy_dephase, exp_sz_dephase = result_phase.expect# type: ignore
exp_sx_dephase , exp_sy_dephase, exp_sz_dephase= (
    np.array(exp_sx_dephase),
    np.array(exp_sy_dephase),
    np.array(exp_sz_dephase),
)

b_phase = Bloch()
b_phase.add_points([exp_sx_dephase , exp_sy_dephase, exp_sz_dephase], meth='l')
b_phase.add_states(psi0)
b_phase.show()
plt.show()

#----------- Changing phase -------------------------------------------------#

#----------- Qubit relaxation -------------------------------------------------#

#Another type of dissipation is the relaxation of the qubit 
# Originating form the following collapse operator:
# C = [sqrt(gr) * sigma_] 
# This induces spontaneous flips of the qubit from the excited state to the ground state.
# With a rate gr. We can observe the qubit dynamics on the Bloch sphere by defining:
g_relax = 0.5 # Change and observe later what happens
c_ops3 = [np.sqrt(g_relax) * sigmam()]

# Solve the dynamics
result_relax = mesolve(H,psi0,tlist,c_ops3, [sigmax(), sigmay(), sigmaz()])
exp_sx_relax , exp_sy_relax, exp_sz_relax = result_relax.expect# type: ignore

b_relax = Bloch()
b_relax.add_points([exp_sx_relax , exp_sy_relax, exp_sz_relax], meth='l')
b_relax.add_states(psi0)
b_relax.show()
plt.show()

#----------- Qubit relaxation -------------------------------------------------#


#NB!With these methods you can explore different hamiltonians and dissipation processes
# Also simulate any dissipative quantum system , whose dynamics are described by the master eq. 
# See the qutip documentation for more details : http://qutip.org/docs/latest/guide/dynamics/dynamics-master.html