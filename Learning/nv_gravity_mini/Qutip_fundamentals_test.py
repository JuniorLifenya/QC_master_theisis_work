import numpy as np
import qutip as qt
import matplotlib.pyplot as plt
from qutip import (Qobj, about, basis, coherent, coherent_dm, create, destroy,
                   expect, fock, fock_dm, mesolve, qeye, sigmax, sigmay,
                   sigmaz, tensor, thermal_dm, anim_matrix_histogram,
                   anim_fock_distribution, Bloch, fidelity, concurrence,sigmam,sigmap)

# We set a parameter to see animations in line 
from matplotlib import rc
rc('animation', html='jshtml')

#----------- Introduction --------------------------------------------------#

q1 = Qobj([[1, 0], [0, 0]])  # |0><0| Well this one is apparently an operator
q2 = Qobj([[1], [0]])  # |0> This is just a state vector with one column
#print(q1)
#print(q2)

# Useful properties of Qobj 
# print(f"Shape of q1 is: {q1.shape}")
# print(f"Type of q1 is: {q1.type}")
# print(f"Dimension of q1 is: {q1.dims}")
# print(f"Is q1 Hermitian? {q1.isherm}")
# print(f"Is q1 unitary? {q1.isunitary}")
# print(f"Dense matrix representation of q1:\n{q1.full()}")
# print(f"Conjugate transpose of q1:\n{q1.dag()}")
# print(f"Eigenvalues of q1: {q1.eigenenergies()}")

# Now faster with fundamental basis states (Fock states of oscillatior modes)

basis(2, 0)  # |0> same as fock(2,0)
basis(2, 1)  # |1> same as fock(2,1)
basis(2, 0).dag()  # <0| same as fock(2,0).dag()
basis(2, 1).dag()  # <1| same as fock(2,1).dag()


print(f"|0> : {basis(2, 0)}")  # |0> same as fock(2,0)
print(f"|1> : {basis(2, 1)}")  # |1> same as fock(2,1)
print(f" |0><0| : {(basis(2, 0) * basis(2, 0).dag())} \n")   # |0><0| same as fock_dm(2,0)

#----------State vectors with three components-------------------#
basis(3, 0)  # |1>
basis(3, 1)  # |0>  
basis(3, 2)  # |-1>

print(f"|1> : {basis(3, 0)}")  # |1>
print(f"|0> : {basis(3, 1)}")  # |0>  
print(f"|-1> : {basis(3, 2)}")  # |-1>

#-----------Now for a Density matrix-----------------------------#
fock_dm(2, 0)  # |0><0|
fock_dm(5,1)  # |1><1| in a 5-dim hilbert-space 1 as occupied state
fock_dm(5,2)  # |2><2| in a 5-dim hilbert-space 2 as occupied state

print(f"Density matrix |0><0| in 2-dim space:\n{fock_dm(2, 0)}")  # |0><0| in 2-dim space 
print(f"Density matrix |1><1| in 5-dim space:\n{fock_dm(5,1)}")  # |1><1| in a 5-dim hilbert-space 
print(f"Density matrix |2><2| in 5-dim space:\n{fock_dm(5,2)} \n")  # |2><2| in a 5-dim hilbert-space

#----------Decoherent state as density matrix--------------------#

coherent_dm(5,2)  # Coherent state with alpha = 2 in a 5-dim hilbert-space
print(f"Density matrix of a coherent state with alpha = 2 in 5-dim space:\n{coherent_dm(5,2)} \n")


#----------Operators properties----------------------------------#

destroy(N=2)  # Annihilation operator in a 2-dim hilbert-space
create(N=2)  # Creation operator in a 2-dim hilbert-space
qeye(3)  # Identity operator in a 2-dim hilbert-space
sigmax()  # Pauli X operator
sigmay()  # Pauli Y operator
sigmaz()  # Pauli Z operator
sigmam()  # Lowering operator
sigmap()  # Raising operator
tensor(sigmax(), sigmay())  # Tensor product of two operators

# We can also use the annihilation operator to construct the position operator

a = destroy(3)

x_op = (a + a.dag()) / np.sqrt(2)  # Position operator in 3-dim space
p_op = 1j * (a.dag() - a) / np.sqrt(2)  # Momentum operator in 3-dim space

# We can define the commutator of two operators A and B as [A, B] = AB - BA
def commutator(A, B):
    return A * B - B * A
print(f"Commutator [x, p]:\n{commutator(x_op, p_op)} \n")  # Should be close to i*I

# But the last diagonal is

#----------- Introduction ---------------------------------------------------#

#----------- Simple setup ---------------------------------------------------#

# We will start with a simple model of an NV-center as a spin-1 system.
# In doing so we define H = [delta/2]sigmax 
# We define an additional collaps operator , describing the dissipation
# Of energy from the qubit to an external environment. C = [sqrt(g)]sigmaz

delta = 2* np.pi 

g = 0.25 

# Hamiltonian 
H = (delta/2) * sigmax()

# Collapse operators
c_ops = [np.sqrt(g) * sigmaz()]

# Initial state
psi0 = basis(2,0)  # Ground state

# Time vector
tlist = np.linspace(0, 5, 100)

#----------- Simple setup ---------------------------------------------------#

res = mesolve(H,psi0,tlist,c_ops,[sigmaz()])

# For this perticular Hamiltonian and dissipation process , we can derive 
# The analytical solution for the expectation value of sigmaz

sz_analytical = np.cos(2*np.pi*tlist) * np.exp(-g*tlist)

#We can acces the expectation value generated by the mesolve by accesing res.expect[0]


plt.scatter(tlist,res.expect[0],label='Numerical ')
plt.scatter(tlist, res.expect[0], c = "r", marker = "x", label = "mesolve")
plt.plot(tlist,sz_analytical, label = "Analytical", c = "k")
plt.xlabel('Time'), plt.ylabel('<sigmaz>')
plt.legend()
plt.grid()
plt.title("Qubit dynamics with dissipation")
plt.show()


#----------- Bloch sphere ---------------------------------------------------#

# First consider the following hamiltonian H = delta(costsigmaz + sintsigmax)
# t defines the angle of the qubit state between the z-axis towards the x-axis 
# We can again use mesolve to obtain the dynamics of the system.
# Here we pass an ampty list of collapse operators to indicate that we do not
# Want to include any dissipation in the system

t = 0.2*np.pi

H = delta *(np.cos(t) * sigmaz() + np.sin(t) * sigmax())

# Obtain Time Evolution 
tlist = np.linspace(0,5,200) # Change for better resolution, sircle-radius and smoothness
result = mesolve(H, psi0, tlist, [], [sigmax(), sigmay(), sigmaz()])


# We can visulaize the state on the Bloch sphere using qutip.Bloch class. 
# We can add points to the Block sphere and also vectors representing states. 

exp_sx_circ, exp_sy_circ, exp_sz_circ = result.expect 
exp_sx_circ, ex_sy_circ,  exp_sz_circ = (
    np.array(exp_sx_circ),
    np.array(exp_sy_circ),
    np.array(exp_sz_circ),
)

b = Bloch()
b.add_points([exp_sx_circ, exp_sy_circ, exp_sz_circ], 'm') # 's' for sphere and 'l' for line, you can also mix them 
b.add_states(psi0)

# Create a larger figure so the title has room (optional)
b.fig = plt.figure(figsize=(9, 9))
# Put suptitle on the figure before drawing
b.fig.suptitle("Coherent evolution", fontsize=40, y=0)

# Make room at the top so the title isn't clipped
b.fig.subplots_adjust(top=0.98)
b.show()
#plt.show()

#----------- Bloch sphere ---------------------------------------------------#

#----------- Changing phase -------------------------------------------------#

#To change the phase we introduce the following collapse operator:
# C = [sqrt(g) * sigmay] 
g_phase = 0.5 # Change and observe later what happens(more sircle rounds)
c_ops2 = [np.sqrt(g_phase) * sigmaz()]

# Solve the dynamics
result_phase = mesolve(H,psi0,tlist,c_ops2, [sigmax(), sigmay(), sigmaz()])
exp_sx_dephase , exp_sy_dephase, exp_sz_dephase = result_phase.expect# type: ignore
exp_sx_dephase , exp_sy_dephase, exp_sz_dephase= (
    np.array(exp_sx_dephase),
    np.array(exp_sy_dephase),
    np.array(exp_sz_dephase),
)

b_phase = Bloch()
b_phase.add_points([exp_sx_dephase , exp_sy_dephase, exp_sz_dephase], meth='l')
b_phase.add_states(psi0)

# Create a larger figure so the title has room (optional)
b_phase.fig = plt.figure(figsize=(9, 9))  
# Put suptitle on the figure before drawing
b_phase.fig.suptitle("Dephasing with rate g = 0.5", fontsize=40, y=0)

# Make room at the top so the title isn't clipped
b_phase.fig.subplots_adjust(top=0.98)
b_phase.show()
#plt.show()

#----------- Changing phase -------------------------------------------------#

#----------- Qubit relaxation -----------------------------------------------#

#Another type of dissipation is the relaxation of the qubit 
# Originating form the following collapse operator:
# C = [sqrt(gr) * sigma_] 
# This induces spontaneous flips of the qubit from the excited state to the ground state.
# With a rate gr. We can observe the qubit dynamics on the Bloch sphere by defining:
g_relax = 0.5 # Change and observe later what happens
c_ops3 = [np.sqrt(g_relax) * sigmam()]

# Solve the dynamics
result_relax = mesolve(H,psi0,tlist,c_ops3, [sigmax(), sigmay(), sigmaz()])
exp_sx_relax , exp_sy_relax, exp_sz_relax = result_relax.expect# type: ignore

b_relax = Bloch()
b_relax.add_points([exp_sx_relax , exp_sy_relax, exp_sz_relax], meth='l')
b_relax.add_states(psi0)

# Create a larger figure so the title has room 
b_relax.fig = plt.figure(figsize=(9, 9))
# Put subtitle on the figure before drawing
b_relax.fig.suptitle("Relaxation with rate gr = 0.5", fontsize=40, y=0)

# Make room at the bottom so the title isn't clipped
b_relax.fig.subplots_adjust(top=0.98)
b_relax.show()
#plt.show()

#----------- Qubit relaxation -----------------------------------------------#


#NB!With these methods you can explore different hamiltonians and dissipation processes
# Also simulate any dissipative quantum system , whose dynamics are described by the master eq. 
# See the qutip documentation for more details : http://qutip.org/docs/latest/guide/dynamics/dynamics-master.html



#//////////////////////Now we level up the game///////////////////////////////

#----------More advanced definitions-----------------------------------------#

# Define NV-center spin-1/2 operators
Sx = qt.jmat(1/2, 'x') 
Sy = qt.jmat(1/2, 'y')
Sz = qt.jmat(1/2, 'z')

# Define squared operators
Sx2 = Sx * Sx 
Sy2 = Sy * Sy 
Sz2 = Sz * Sz

# For spin-1 operators we simply have 
S1x = qt.jmat(1, 'x')
S1y = qt.jmat(1, 'y')
S1z = qt.jmat(1, 'z')

#-------- We check their properties------------------------------------------#
print(f" S_x : {Sx } \n")
print(f" S_1x: {S1x } \n")
print(f"Shape of S_x is: {Sx.shape}")
print(f"Type of S_x is: {Sx.type}")
print(f"Dimension of S_x is: {Sx.dims}")



#-------- We check their properties------------------------------------------#


#----------More advanced definitions-----------------------------------------#